<!DOCTYPE html>
<html lang="en">
<head>
    <title>dc.js - Range / Focus Ordinal Bar Chart</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="../css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="../css/dc.css"/>
</head>
<body>

<div class="container">
<script type="text/javascript" src="header.js"></script>
<p>This example demonstrates using range and focus charts to scroll an ordinal bar chart
  with too many items.</p>
<p>Since ordinal-scale charts are not ordinarily brushable or zoomable, the example maps
  the ordinal values to integers, and then maps the integers back to the values for the
  axis ticks and bar titles.</p>
<div id="range"></div>
<div id="focus">
  <a class="reset" style="visibility: hidden" href="javascript:focus.filterAll(); dc.redrawAll()">reset</a>
</div>
<div id="first-letters"></div>

<script type="text/javascript" src="../js/d3.js"></script>
<script type="text/javascript" src="../js/crossfilter.js"></script>
<script type="text/javascript" src="../js/dc.js"></script>
  <style>
  #focus .axis.x .tick text {
    text-anchor: end;
    transform: rotate(-60deg) translate(-10px,-12px);
  }
  #range.dc-chart .axis {
    display: none;
  }
  #range svg {
      display: block; /* default inline causes padding? */
  }
  </style>
  <script type="text/javascript">
    // we need a slight delay to enable debounce, but a large delay is annoying for brushing
    dc.constants.EVENT_DELAY = 10;

    class Mapper {
        constructor (keys) {
            this._int2ord = [];
            this._ord2int = {};

            keys.forEach(key => {
                if(!this._ord2int.hasOwnProperty(key)) {
                    this._ord2int[key] = this._int2ord.length;
                    this._int2ord.push(key);
                }
            });
        }

        ord2int(ord) {
            return this._ord2int[ord];
        }

        int2ord(i) {
            return this._int2ord[i];
        }

        length() {
            return this._int2ord.length;
        }
    }

    // phrases generated with https://www.fourmilab.ch/javascrypt/pass_phrase.html
    var focus, range;
    d3.json("wide-ordinal.json").then(function(wide) {
        // extract and sort keys, these will be assigned indices starting from 0 by the mapper
        const keys = wide.map(d => d.key).sort((a,b) => d3.ascending(a,b));
        const mappings =  new Mapper(keys);

        // dummy crossfilter taking group data and regrouping it to the same thing
        var cf = crossfilter(wide),
            dimension = cf.dimension(function(d) {return mappings.ord2int(d.key);}),
            group = dimension.group().reduceSum(function(d) {return d.value;});

        focus = new dc.BarChart('#focus');
        var linear_domain = [-0.5, mappings.length() - 0.5];
        focus
            .width(1000).height(330)
            .margins({left: 60, top: 0, right: 10, bottom: 145})
            .x(d3.scaleLinear().domain(linear_domain))
            .xUnits(dc.units.integers)
            .controlsUseVisibility(true)
            .centerBar(true)
            .yAxisLabel('counts')
            .elasticY(true)
            .brushOn(false)
            .dimension(dimension)
            .mouseZoomable(true)
            .zoomScale([4,8])
            .configure({autoFocus: true})
            .group(group)
            .title(kv => mappings.int2ord(kv.key))
            .transitionDuration(0);

        focus.xAxis()
            .tickFormat(function(d) { return mappings.int2ord(d); });

        focus.on('preRedraw', function(chart) {
            var domain = chart.x().domain(),
                min = Math.ceil(domain[0]), max = Math.floor(domain[1]);
            chart.xAxis().tickValues(d3.range(min, max+1));
        });

        range = new dc.BarChart('#range');
        range
            .margins({left: 74, top: 0, right: 20, bottom: 2})
            .width(1000).height(20)
            .x(d3.scaleLinear().domain(linear_domain))
            .xUnits(dc.units.integers)
            .elasticY(true)
            .brushOn(true)
            .dimension(dimension)
            .group(group)
            .transitionDuration(0);

        // display a row chart of first letters, to test filtering
        var letterDimension = cf.dimension(function(d) {
            return d.key.split(' ').map(function(s) { return s[0]; });
        }, true);
        var letterGroup = letterDimension.group();

        var row = new dc.RowChart('#first-letters');
        row
            .width(1000)
            .height(350)
            .gap(1)
            .elasticX(true)
            .dimension(letterDimension)
            .transitionDuration(200)
            .group(letterGroup);

        dc.renderAll();

        // Set initial focus
        focus
            .focus([200,260])

    });

</script>

</div>
</body>
</html>
